# Using ssh-agent with security keys

ssh-agent is normally used to load private keys into memory, so you don't have to enter the passphrase that protects the private key multiple times.
Instead, the passphrase is only required to decrypt the private key when adding the key to ssh-agent with `ssh-add`.

Because security keys cannot export private keys, SSH keys cannot be loaded into memory by ssh-agent.
Instead, a reference (the credential ID) to the private key is loaded.
This is why it doesn't make sense to use a passphrase to protect the private key file - it doesn't contain a private key.
It also means ssh-agent is not often used with security keys.

There are exceptions though. For instance:

1. When both UV and UP are not required. Although that is usually not a good idea (the security key is reduced to a posession-only factor), it may make sense in some automation scenarios where it is unfeasible to perform UV/UP a large number of times.
2. When using agent-forwarding, i.e. using SSH agent on a client to access a private key on a server.

In this exercise we consider the second scenario.

# Using ssh-agent with s security key

Agent forwarding can be dangerous if you sign in to a rogue server - the server can access the agent running on your client remotely, and use private keys stored in memory unnoticed..
When using a security key, you can mitigate this risk by requiring user presence or even user verification.

- Open a terminal and launch ssh-agent in the foreground

```
/usr/bin/ssh-agent -d
```

Note the environment variable export (`SSH_AUTH_SOCK`) printed on stdout.

- Open a second terminal and export `SSH_AUTH_SOCK` according to the output in the first terminal:

```
SSH_AUTH_SOCK=...; export SSH_AUTH_SOCK;
```

- Generate a new SSH key using the default options (UP but not UV):

```
ssh-keygen -t ecdsa-sk -f ./id_ecdsa_sk -N ""
```

- Verify you can use local signing using your private key:

```
echo hello | ssh-keygen -Y sign -f ./id_ecdsa_sk -n test
```

- Remove any keys present in ssh-agent:

```
ssh-add -D
```

- Add your new key to ssh-agent:

```
ssh-add ./id_ecdsa_sk
```

- Verify it is now listed:

```
ssh-add -l
```

- Verify you can perform local signing using the agent:

```
echo hello | ssh-keygen -Y sign -f ./id_ecdsa_sk.pub -n test
```
Note that by referring to the public key, we are now using the signing key through ssh-agent.

# Agent forwarding

- Use the Dockerfile to launch an SSH server
```
docker build --build-arg user=ubuntu -t ssh-server .
docker run --rm -d -p 22:22 --name ssh_demo ssh-server
```

- Copy the public key to the server:

```
scp ./id_ecdsa_sk.pub ubuntu@localhost:.
```

- Sign into the server using agent forwarding:

```
ssh -A ubuntu@localhost
```
Note that only our public key is present on the server - 
the private key resides on the security key connected to our client.
The private key can however be accessed because of ssh-agent forwarding.

- Signed in on the server, sign some data:
```
echo hello | ssh-keygen -Y sign -f id_ecdsa_sk.pub -n test
```

Note that the signature requires user presence: no silent use of the private key is possible.
See also the logging generated by ssh-agent in your other terminal window.

# Using UV

Repeat the exercise, but now also require user verification (`-O verify-required`).
The problem now is that usually, ssh-agent does not have a TTY to prompt for the PIN.
This can be solved by a helper program such as `ssh-askpass`.

- Install a version of `ssh-askpass` on your client system that allows reading PINs without a terminal.

- Let ssh-agent know how to ask for a PIN:

```
export SSH_ASKPASS=ssh-askpass
```

If you do not have a `$DISPLAY` set, you may also need to specify:

```
export SSH_ASKPASS_REQUIRE=force
```

- Again, sign into the server using agent forwarding:

```
ssh -A ubuntu@localhost
```

This time, you will be asked for the PIN.
Depending on your environment, the PIN prompt will appear in your terminal window, or in a separate window created by ssh-askpass.

- Once signed in, sign a dummy message:
```
echo hello | ssh-keygen -Y sign -f id_ecdsa_sk.pub -n test
```

A window should appear on your client system asking for the PIN, and if the PIN verifies, 
the message is signed on the server using the key residing on the security key connected to your client system.
